---
title: "Classification of Acute Respiratory Distress Syndrome"
author: "Robert Edwards"
output:
  
  pdf_document:
    
    latex_engine: pdflatex
    number_sections: no
    fig_caption: yes
  word_document: default
  html_document:
    
    code_folding: hide
    df_print: paged
    fig_caption: yes
geometry: "left=3cm,right=3cm,top=3cm,bottom=3cm"
header-includes: 
  \usepackage[bottom]{footmisc}
  \usepackage{float}
  \floatplacement{figure}{H}
  \usepackage{color}
  \usepackage{xcolor}
---

```{r setup, include=FALSE, echo = FALSE, eval = TRUE}
knitr::opts_chunk$set(echo = FALSE, eval = TRUE, warning = FALSE, message = FALSE, comment = NA)
options()
```

```{r libraries, echo = FALSE, eval = TRUE, warning = FALSE, message = FALSE}
library(ggplot2)
library(dplyr)
library(moderndive)
library(skimr)
library(tidyr)
library(kableExtra)
library(gridExtra)
library(xtable)
library(knitr)
library(GGally)
library(broom)
library(naniar) # missing data eda
library(VIM) # data imputation
```

```{r import_data, echo = FALSE, eval = TRUE, warning = FALSE, message = FALSE}
data.raw.df <- read.csv(file = "../data/ARDSdata.csv", header = TRUE)
```


```{r reduce, echo = FALSE, eval = TRUE, warning = FALSE, message = FALSE}
Day1_vars <- c("Hospital_Survival", 
               "Duration_ECMO",
               "Day1ECMO_RR", 
               "Day1ECMO_Vt", 
               "Day1ECMO_FiO2", 
               "Day1ECMO_Ppeak", 
               "Day1ECMO_Pmean", 
               "Day1ECMO_PEEP", 
               "Day1ECMO_PF", 
               "Day1ECMO_SpO2", 
               "Day1ECMO_PaCO2", 
               "Day1ECMO_pH", 
               "Day1ECMO_BE", 
               "Day1ECMO_Lactate", 
               "Day1ECMO_NAdose", 
               "Day1ECMO_MAP", 
               "Day1ECMO_Creatinine", 
               "Day1ECMO_Urea", 
               "Day1ECMO_CK", 
               "Day1ECMO_Bilirubin", 
               "Day1ECMO_Albumin", 
               "Day1ECMO_CRP", 
               "Day1ECMO_Fibrinogen", 
               "Day1ECMO_Ddimer", 
               "Day1ECMO_ATIII", 
               "Day1ECMO_Leukocytes", 
               "Day1ECMO_Platelets", 
               "Day1ECMO_TNFa", 
               "Day1ECMO_IL6", 
               "Day1ECMO_IL8", 
               "Day1ECMO_siIL2")
data.df <- data.raw.df[, -which(names(data.raw.df) %in% Day1_vars)]
```


```{r slicing, echo = FALSE, eval = FALSE, warning = FALSE, message = FALSE, results="hide"}
# Select the first 450 rows.  The others are blank
data.df <- data.df %>%
  slice(1:450) 
#  suppressMessages()  # suppress output
```

```{r factor, echo = FALSE, eval = FALSE, warning = FALSE, message = FALSE, results="hide"}
# Make categorical variables factors
data.df <- data.df %>%
  mutate(Indication = factor(Indication)) %>% 
  mutate(ECMO_Survival = factor(ECMO_Survival)) %>%
  mutate(Gender = factor(Gender)) %>%
  suppressMessages()  # suppress output
```


```{r missing_data, echo = FALSE, eval = TRUE, warning = FALSE, message = FALSE}
vis_miss(data.df)
```

An upset plot from the `UpSetR` package can be used to visualise the patterns of missingness, or rather the combinations of missingness across cases. To see combinations of missingness and intersections of missingness amongst variables, use the `gg_miss_upset` function:

```{r missing_data_patterns, echo = FALSE, eval = TRUE, warning = FALSE, message = FALSE}
gg_miss_upset(data.df)
```

If there are 40 intersections, there will be up to 40 combinations of variables explored. The number of sets and intersections can be changed by passing arguments `nsets = 10` to look at 10 sets of variables, and nintersects = 50 to look at 50 intersections.

```{r num_missing, echo = FALSE, eval = TRUE, warning = FALSE, message = FALSE}
#n_var_miss(data.df)
gg_miss_upset(data.df, nsets = n_var_miss(data.df)/3)
```

This plot shows the number of missing values in each variable in a dataset. It is powered by the `miss_var_summary()` function.  
```{r var_missing, echo = FALSE, eval = TRUE, warning = FALSE, message = FALSE}
gg_miss_var(data.df, show_pct = TRUE) +
  labs("% Data Missing in Biomarker Data")
```

This plot shows the number of missings in each column, broken down by a categorical variable from the dataset. It is powered by a `dplyr::group_by` statement followed by `miss_var_summary()`.

```{r missing_fct, echo = FALSE, eval = TRUE, warning = FALSE, message = FALSE}
gg_miss_fct(x = data.df, fct = Indication) + 
  labs("NAs in Biomarkers by Age")
```

This plot shows the cumulative sum of missing values, reading the rows of the dataset from the top to bottom. It is powered by the `miss_case_cumsum()` function.

```{r cum_missing, echo = FALSE, eval = TRUE, warning = FALSE, message = FALSE}
gg_miss_case_cumsum(data.df)
```


This plot shows the cumulative sum of missing values, reading columns from the left to the right of your dataframe. It is powered by the `miss_var_cumsum()` function.

```{r cum_var_missing, echo = FALSE, eval = TRUE, warning = FALSE, message = FALSE}
gg_miss_var_cumsum(data.df)
```










#Imputation
Here I will try various methods for data imputation.

##I. KNN Imputation

```{r knn_imputation, echo = FALSE, eval = TRUE, warning = FALSE, message = FALSE}
data_impute.df <- kNN(data.df)

data_impute.df %>%
  glimpse()
```

```{r standardizing, echo = FALSE, eval = TRUE, warning = FALSE, message = FALSE}
# Scaling the data and logging it
feature_names <- colnames(data_impute.df[,7:36])
data_standard.df <- data_impute.df %>%
  select(7:36) %>%
  mutate_each_(funs(scale), vars=feature_names) %>%
  mutate_each_(funs(log), vars=feature_names) %>%
  glimpse()

data_standard.df %>% 
  gather(key = Feature, value = Value) %>% 
  ggplot(aes(x = Feature, y = Value, fill = Feature)) +
#  ggplot(stack(track_features.df), aes(x = ind, y = values)) +
    geom_boxplot() +
    xlab("Features") + 
    ylab("Average") + 
    theme_bw() +
    theme(plot.title = element_text(hjust = 0.5),
          legend.position="none",
          axis.text.x = element_text(angle = 60, hjust = 1)) + 
    scale_fill_brewer(palette="Spectral")
```


```{r, echo = FALSE, eval = TRUE, warning = FALSE, message = FALSE}
data_standard.df %>% 
  gather(key = Feature, value = Value) %>% 
  ggplot(aes(x=Value, color=Feature)) +
      geom_density(alpha=0.5) +
      geom_vline(aes(xintercept=0)) +
      theme_bw() +
      scale_fill_brewer(palette="Spectral") 
```



#Training/Test Data
```{r, echo = FALSE, eval = TRUE, warning = FALSE, message = FALSE, results = "hide"}
#feature_names <- colnames(data.df[,7:36])
#data_standard <- data.df %>%
#  select(7:36) %>%
#  mutate_each_(funs(scale), vars=feature_names) %>%
#  mutate_each_(funs(log), vars=feature_names) %>%
#  glimpse()

# Reordering columns
data_standard <- cbind(data.df[,c(1,5,2,4,3)], data.df[6:ncol(data.df)]) 

standardized <- apply(data_standard[, 5:ncol(data_standard)], 2, scale)  # scale the features
data_standard <- cbind(data_standard[,1:4], standardized)  # rebind variables

data_standard <- data_standard %>% 
  mutate(Gender = ifelse(data_standard$Gender == "m" , 0, 1)) %>% # male = 0, female = 1
  mutate(ECMO_Survival = ifelse(data_standard$ECMO_Survival == "Y" , 1, 0)) # Yes = 1, No = 0
#  mutate(Hospital_Survival = ifelse(data_standard$Hospital_Survival == "Y" , 1, 0)) # Yes = 1, No = 0

data_standard <- data_standard %>%
  mutate(Indication = factor(Indication)) %>% 
  mutate(ECMO_Survival = factor(ECMO_Survival)) %>%
#  mutate(Hospital_Survival = factor(Hospital_Survival)) %>%
  mutate(Gender = factor(Gender)) %>%
  suppressMessages()  # suppress output

data_standard %>%
  glimpse()
```

##Dropping NAs from dataset
```{r, echo = FALSE, eval = TRUE, warning = FALSE, message = FALSE}
data_standard_drop <- data_standard %>% 
  select(-PreECMO_Albumin) %>%  # Drop variable missing >50% data
  drop_na()  # Drop rows missing data

data_standard_drop %>%
  nrow()
```

```{r, echo = FALSE, eval = TRUE, warning = FALSE, message = FALSE}
set.seed(123)
data.ARDS <- data_standard_drop

n <- nrow(data.ARDS)
ind1 <- sample(c(1:n), round(n / 2))
ind2 <- sample(c(1:n)[-ind1], round(n / 4))
ind3 <- setdiff(c(1:n), c(ind1, ind2))
train.ARDS <- data.ARDS[ind1, ]
valid.ARDS <- data.ARDS[ind2, ]
test.ARDS <- data.ARDS[ind3, ]
```


```{r model1, echo = FALSE, eval = TRUE, warning = FALSE, message = FALSE}
model_logit <- glm(ECMO_Survival ~ . , data=train.ARDS, family=binomial(link="logit"))

model_logit %>%
  summary()
```

A quick note about the plogis function: The `glm()` procedure with `family="binomial"` will build the logistic regression model on the given formula. When we use the `predict` function on this model, it will predict the log(odds) of the Y variable. This is not what we ultimately want because, the predicted values may not lie within the 0 and 1 range as expected. So, to convert it into prediction probability scores that is bound between 0 and 1, we use the `plogis()`.  For more info see (blog on logisitic regression)[http://r-statistics.co/Logistic-Regression-With-R.html]. 

```{r predict1, echo = FALSE, eval = TRUE, warning = FALSE, message = FALSE}
## Using the predict function to predict for the validation data.
pred.valid <- plogis(predict(model_logit, valid.ARDS))  # predicted scores
```

###Optimal Prediction Probability Cutoff for the Model
The default cutoff prediction probability score is 0.5 or the ratio of ---- in the training data. But sometimes, tuning the probability cutoff can improve the accuracy in both the development and validation samples. The `InformationValue::optimalCutoff` function provides ways to find the optimal cutoff to improve the prediction of ----, ----, both ---- and ---- and o reduce the misclassification error. Let's compute the optimal score that minimizes the misclassification error for the above model.

```{r cutoff1, echo = FALSE, eval = TRUE, warning = FALSE, message = FALSE}
# Find the optimal cutoff value to use (default = 0.5)
library(InformationValue)
opt_cutoff <- optimalCutoff(test.ARDS$ECMO_Survival , pred.valid)[1] 

## Changing the predictions to predited labels.
pred.valid.label <- ifelse(round(pred.valid) <= 0.5, 0, 1)

## Changing the predictions to predited labels.
pred.valid.label.opt <- ifelse(round(pred.valid) <= opt_cutoff, 0, 1)

```

##Model Diagnostics
```{r xtab1, echo = FALSE, eval = TRUE, warning = FALSE, message = FALSE}
## Cross-classification table.
logit.table <- table(valid.ARDS$ECMO_Survival, pred.valid.label)
## Correct classification rate (CCR).
sum(pred.valid.label == valid.ARDS$ECMO_Survival) / length(pred.valid.label)
## Class-specific CCRs.
diag(logit.table) / rowSums(logit.table)

## Cross-classification table.
logit.table.opt <- table(valid.ARDS$ECMO_Survival, pred.valid.label.opt)
## Correct classification rate (CCR).
sum(pred.valid.label == valid.ARDS$ECMO_Survival) / length(pred.valid.label.opt)
## Class-specific CCRs.
diag(logit.table) / rowSums(logit.table)
```


##Imputed Dataset
```{r , echo = FALSE, eval = TRUE, warning = FALSE, message = FALSE}
data_standard_drop <- data_standard %>%
  select(-PreECMO_Albumin) # Drop variable missing >50% data

data_impute <- kNN(data_standard_drop)

data_impute <- data_impute %>%
  select(1:33)
```

```{r, echo = FALSE, eval = TRUE, warning = FALSE, message = FALSE}
set.seed(123)

data.ARDS <- data_impute

n <- nrow(data.ARDS)
ind1 <- sample(c(1:n), round(n / 2))
ind2 <- sample(c(1:n)[-ind1], round(n / 4))
ind3 <- setdiff(c(1:n), c(ind1, ind2))
train.ARDS <- data.ARDS[ind1, ]
valid.ARDS <- data.ARDS[ind2, ]
test.ARDS <- data.ARDS[ind3, ]
```

```{r model2, echo = FALSE, eval = TRUE, warning = FALSE, message = FALSE}

model_logit <- glm(ECMO_Survival ~ . , data=train.ARDS, family=binomial(link="logit"))

model_logit %>%
  summary()
```

```{r predict2, echo = FALSE, eval = TRUE, warning = FALSE, message = FALSE}
## Using the predict function to predict for the validation data.
pred.valid <- plogis(predict(model_logit, valid.ARDS))  # predicted scores
```

```{r cutoff2, echo = FALSE, eval = TRUE, warning = FALSE, message = FALSE}
# Find the optimal cutoff value to use (default = 0.5)
library(InformationValue)
opt_cutoff <- optimalCutoff(test.ARDS$ECMO_Survival , pred.valid)[1] 

## Changing the predictions to predited labels.
pred.valid.label <- ifelse(round(pred.valid) <= 0.5, 0, 1)

## Changing the predictions to predited labels.
pred.valid.label.opt <- ifelse(round(pred.valid) <= opt_cutoff, 0, 1)

```

##Model Diagnostics

```{r xtab2, echo = FALSE, eval = TRUE, warning = FALSE, message = FALSE}
## Cross-classification table.
logit.table <- table(valid.ARDS$ECMO_Survival, pred.valid.label)
## Correct classification rate (CCR).
sum(pred.valid.label == valid.ARDS$ECMO_Survival) / length(pred.valid.label)
## Class-specific CCRs.
diag(logit.table) / rowSums(logit.table)

## Cross-classification table.
logit.table.opt <- table(valid.ARDS$ECMO_Survival, pred.valid.label.opt)
## Correct classification rate (CCR).
sum(pred.valid.label == valid.ARDS$ECMO_Survival) / length(pred.valid.label.opt)
## Class-specific CCRs.
diag(logit.table) / rowSums(logit.table)
```

















